<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>苏苏图片编辑器 - 圆形裁剪优化版</title>
  <style>
    /* 重置和基础样式 */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: linear-gradient(135deg, #ece9e6, #ffffff);
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      margin-bottom: 20px;
      text-align: center;
      color: #333;
      font-size: 2.5em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }

    .container {
      background-color: #ffffff;
      padding: 25px 30px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      width: 100%;
      max-width: 800px; /* 增加宽度以适应Canvas */
      animation: fadeIn 0.5s ease-in-out;
    }

    /* 渐变按钮样式 */
    .menu {
      display: flex;
      justify-content: space-around;
      margin-bottom: 25px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .menu button {
      padding: 12px 20px;
      margin: 5px;
      border: none;
      border-radius: 25px;
      background: linear-gradient(45deg, #ff7e5f, #feb47b);
      color: white;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
      font-size: 1em;
      flex: 1 1 30%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .menu button:hover {
      background: linear-gradient(45deg, #feb47b, #ff7e5f);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    .menu button.active {
      background: linear-gradient(45deg, #6a11cb, #2575fc);
    }

    .module {
      display: none;
      padding: 20px;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      background-color: #fafafa;
      transition: all 0.3s;
      animation: slideIn 0.3s ease-in-out;
    }

    .module.active {
      display: block;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      margin-bottom: 20px;
    }

    label {
      margin-bottom: 8px;
      color: #555;
      font-weight: 600;
      font-size: 1em;
    }

    input[type="file"],
    input[type="number"],
    select,
    input[type="range"],
    button {
      padding: 12px 14px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 1em;
      outline: none;
      transition: border-color 0.3s, box-shadow 0.3s;
      width: 100%;
    }

    input[type="file"]:focus,
    input[type="number"]:focus,
    select:focus,
    input[type="range"]:focus {
      border-color: #6a11cb;
      box-shadow: 0 0 8px rgba(106, 17, 203, 0.3);
    }

    /* 执行和复原按钮样式 */
    button.execute-btn {
      background: linear-gradient(45deg, #43cea2, #185a9d);
      color: white;
      cursor: pointer;
      border: none;
      width: 48%;
      align-self: flex-start;
      margin-top: 15px;
      padding: 12px 0;
      border-radius: 25px;
      font-weight: bold;
      transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    button.execute-btn:hover {
      background: linear-gradient(45deg, #185a9d, #43cea2);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    button.restore-btn {
      background: linear-gradient(45deg, #ff4b1f, #ff9068);
      color: white;
      cursor: pointer;
      border: none;
      width: 48%;
      align-self: flex-end;
      margin-top: 15px;
      padding: 12px 0;
      border-radius: 25px;
      font-weight: bold;
      transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    button.restore-btn:hover {
      background: linear-gradient(45deg, #ff9068, #ff4b1f);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    .download-btn {
      background: linear-gradient(45deg, #f7971e, #ffd200);
      color: white;
      cursor: pointer;
      border: none;
      padding: 12px 0;
      border-radius: 25px;
      margin-top: 15px;
      transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
      font-weight: bold;
      width: 100%;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .download-btn:hover {
      background: linear-gradient(45deg, #ffd200, #f7971e);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    .preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
    }

    .preview img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.1);
      margin-bottom: 10px;
      transition: transform 0.3s;
    }

    .preview img:hover {
      transform: scale(1.02);
    }

    .preview-details {
      text-align: center;
      color: #666;
      font-size: 0.95em;
    }

    /* 压缩质量滑块样式 */
    .slider-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .slider-container input[type="range"] {
      flex: 1;
    }

    .slider-percentage {
      width: 50px;
      text-align: center;
      font-weight: bold;
      color: #333;
    }

    /* Canvas样式 */
    #cropCanvas {
      border: 1px solid #ccc;
      border-radius: 8px;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
      margin-top: 15px;
      position: relative;
      display: block;
      background-color: #000; /* 防止在加载图像前闪烁 */
    }

    /* 动画效果 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
      from { opacity: 0; max-height: 0; }
      to { opacity: 1; max-height: 1000px; }
    }

    /* 响应式设计 */
    @media (min-width: 501px) {
      body {
        justify-content: center;
      }

      .container {
        max-width: 90%;
      }

      .menu button {
        flex: 1 1 22%;
        font-size: 1em;
      }
    }
  </style>
</head>
<body>
  <h1>苏苏图片编辑器</h1>
  <div class="container">
    <!-- 功能菜单 -->
    <div class="menu">
      <button data-module="uploadModule" class="active">上传图片</button>
      <button data-module="resizeModule">调整大小</button>
      <button data-module="rotateModule">旋转图片</button>
      <button data-module="compressionModule">压缩质量</button>
      <button data-module="roundedModule">圆角矩形</button>
      <!-- 新增圆形裁剪按钮 -->
      <button data-module="circularCropModule">圆形裁剪</button>
    </div>

    <!-- 上传模块 -->
    <div class="module active" id="uploadModule">
      <h2>上传图片</h2>
      <div class="input-group">
        <input type="file" id="imageUpload" accept="image/*">
      </div>
      <div class="preview" id="originalPreview" style="display: none;">
        <img id="originalImage" src="#" alt="原始图片">
        <div class="preview-details">原始图片预览</div>
      </div>
    </div>

    <!-- 调整大小模块 -->
    <div class="module" id="resizeModule">
      <h2>调整大小</h2>
      <div class="input-group">
        <label for="resizeWidth">宽度 (px)</label>
        <input type="number" id="resizeWidth" min="1">
      </div>
      <div class="input-group">
        <label for="resizeHeight">高度 (px)</label>
        <input type="number" id="resizeHeight" min="1">
      </div>
      <button class="execute-btn" id="resizeButton">执行调整</button>
      <button class="restore-btn" id="restoreResizeButton">复原</button>
      <div class="preview" id="resizePreview" style="display: none;">
        <img id="resizedImage" src="#" alt="调整大小后的图片">
        <div class="preview-details">调整大小后的图片预览</div>
        <button class="download-btn" id="downloadResized">下载调整大小后的图片</button>
      </div>
    </div>

    <!-- 旋转模块 -->
    <div class="module" id="rotateModule">
      <h2>旋转图片</h2>
      <div class="input-group">
        <label for="rotateAngle">旋转角度 (°)</label>
        <input type="number" id="rotateAngle" value="0">
      </div>
      <button class="execute-btn" id="rotateButton">执行旋转</button>
      <button class="restore-btn" id="restoreRotateButton">复原</button>
      <div class="preview" id="rotatePreview" style="display: none;">
        <img id="rotatedImage" src="#" alt="旋转后的图片">
        <div class="preview-details">旋转后的图片预览</div>
        <button class="download-btn" id="downloadRotated">下载旋转后的图片</button>
      </div>
    </div>

    <!-- 压缩质量模块 -->
    <div class="module" id="compressionModule">
      <h2>压缩质量</h2>
      <div class="input-group">
        <label for="compressionQuality">压缩质量 (%)</label>
        <div class="slider-container">
          <input type="range" id="compressionQuality" min="10" max="100" value="80">
          <span class="slider-percentage" id="compressionQualityPercentage">80%</span>
        </div>
      </div>
      <button class="execute-btn" id="compressionButton">执行压缩</button>
      <button class="restore-btn" id="restoreCompressionButton">复原</button>
      <div class="preview" id="compressionPreview" style="display: none;">
        <img id="compressedImage" src="#" alt="压缩后的图片">
        <div class="preview-details">压缩后的图片预览</div>
        <button class="download-btn" id="downloadCompressed">下载压缩后的图片</button>
      </div>
    </div>

    <!-- 圆角矩形模块 -->
    <div class="module" id="roundedModule">
      <h2>圆角矩形</h2>
      <div class="input-group">
        <label for="cornerRadius">圆角半径 (px)</label>
        <input type="number" id="cornerRadius" min="0" value="20">
      </div>
      <button class="execute-btn" id="roundedButton">应用圆角</button>
      <button class="restore-btn" id="restoreRoundedButton">复原</button>
      <div class="preview" id="roundedPreview" style="display: none;">
        <img id="roundedImage" src="#" alt="圆角矩形后的图片">
        <div class="preview-details">圆角矩形后的图片预览</div>
        <button class="download-btn" id="downloadRounded">下载圆角矩形后的图片</button>
      </div>
    </div>

    <!-- 新增圆形裁剪模块 -->
    <div class="module" id="circularCropModule">
      <h2>圆形裁剪</h2>
      <div class="input-group">
        <label for="circleRadius">圆形半径 (px)</label>
        <div class="slider-container">
          <input type="range" id="circleRadius" min="50" max="350" value="150">
          <span class="slider-percentage" id="circleRadiusPercentage">150px</span>
        </div>
      </div>
      <canvas id="cropCanvas"></canvas>
      <div style="display: flex; justify-content: space-between;">
        <button class="execute-btn" id="circularCropButton">执行裁剪</button>
        <button class="restore-btn" id="restoreCircularCropButton">复原</button>
      </div>
      <div class="preview" id="circularCropPreview" style="display: none;">
        <img id="circularCroppedImage" src="#" alt="圆形裁剪后的图片">
        <div class="preview-details">圆形裁剪后的图片预览</div>
        <button class="download-btn" id="downloadCircularCropped">下载圆形裁剪后的图片</button>
      </div>
    </div>
  </div>

  <!-- 隐藏的Canvas用于图像处理 -->
  <canvas id="canvas" style="display: none;"></canvas>

  <script>
    // 全局变量
    let preloadedImage = null; // 预加载的图像对象

    // 获取所有功能按钮
    const menuButtons = document.querySelectorAll('.menu button');

    // 获取所有模块
    const modules = document.querySelectorAll('.module');

    // 当前原始图片数据
    let originalImageData = null;
    let originalImageWidth = 0;
    let originalImageHeight = 0;

    // 获取原始图片元素
    const originalImage = document.getElementById('originalImage');
    const originalPreview = document.getElementById('originalPreview');

    // 获取Canvas和上下文
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // 上传模块元素
    const imageUpload = document.getElementById('imageUpload');

    // 调整大小模块元素
    const resizeWidthInput = document.getElementById('resizeWidth');
    const resizeHeightInput = document.getElementById('resizeHeight');
    const resizeButton = document.getElementById('resizeButton');
    const restoreResizeButton = document.getElementById('restoreResizeButton');
    const resizedImage = document.getElementById('resizedImage');
    const resizePreview = document.getElementById('resizePreview');
    const downloadResized = document.getElementById('downloadResized');

    // 旋转模块元素
    const rotateAngleInput = document.getElementById('rotateAngle');
    const rotateButton = document.getElementById('rotateButton');
    const restoreRotateButton = document.getElementById('restoreRotateButton');
    const rotatedImage = document.getElementById('rotatedImage');
    const rotatePreview = document.getElementById('rotatePreview');
    const downloadRotated = document.getElementById('downloadRotated');

    // 压缩质量模块元素
    const compressionQualityInput = document.getElementById('compressionQuality');
    const compressionQualityPercentage = document.getElementById('compressionQualityPercentage');
    const compressionButton = document.getElementById('compressionButton');
    const restoreCompressionButton = document.getElementById('restoreCompressionButton');
    const compressedImage = document.getElementById('compressedImage');
    const compressionPreview = document.getElementById('compressionPreview');
    const downloadCompressed = document.getElementById('downloadCompressed');

    // 圆角矩形模块元素
    const cornerRadiusInput = document.getElementById('cornerRadius');
    const roundedButton = document.getElementById('roundedButton');
    const restoreRoundedButton = document.getElementById('restoreRoundedButton');
    const roundedImage = document.getElementById('roundedImage');
    const roundedPreview = document.getElementById('roundedPreview');
    const downloadRounded = document.getElementById('downloadRounded');

    // 圆形裁剪模块元素
    const circleRadiusInput = document.getElementById('circleRadius');
    const circleRadiusPercentage = document.getElementById('circleRadiusPercentage');
    const circularCropButton = document.getElementById('circularCropButton');
    const restoreCircularCropButton = document.getElementById('restoreCircularCropButton');
    const circularCroppedImage = document.getElementById('circularCroppedImage');
    const circularCropPreview = document.getElementById('circularCropPreview');
    const downloadCircularCropped = document.getElementById('downloadCircularCropped');
    const cropCanvas = document.getElementById('cropCanvas');
    const cropCtx = cropCanvas.getContext('2d');

    // 功能菜单点击事件
    menuButtons.forEach(button => {
      button.addEventListener('click', () => {
        const targetModule = button.getAttribute('data-module');
        // 移除所有按钮的active状态
        menuButtons.forEach(btn => btn.classList.remove('active'));
        // 添加当前按钮的active状态
        button.classList.add('active');
        // 隐藏所有模块
        modules.forEach(mod => mod.classList.remove('active'));
        // 显示选中的模块
        document.getElementById(targetModule).classList.add('active');

        // 如果切换到圆形裁剪模块，初始化Canvas
        if (targetModule === 'circularCropModule' && originalImageData) {
          initializeCropCanvas();
        }
      });
    });

    // 辅助函数：根据图片大小计算默认圆角半径
    function calculateRadius(size) {
      return Math.round((size / 128) * 30);
    }

    // 上传图片
    imageUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        originalImage.src = event.target.result;
        originalImage.onload = function() {
          originalPreview.style.display = 'flex';
          originalImageData = event.target.result;
          originalImageWidth = originalImage.width;
          originalImageHeight = originalImage.height;

          // 预加载图像
          preloadedImage = new Image();
          preloadedImage.src = originalImageData;
          preloadedImage.onload = () => {
            // 初始化功能模块的输入值

            // 调整大小
            resizeWidthInput.value = originalImage.width;
            resizeHeightInput.value = originalImage.height;

            // 压缩质量
            compressionQualityInput.value = 80;
            compressionQualityPercentage.textContent = '80%';

            // 旋转角度
            rotateAngleInput.value = 0;

            // 圆角输入，根据图片大小自动设置
            const defaultRadius = calculateRadius(originalImage.width);
            cornerRadiusInput.value = defaultRadius;

            // 圆形裁剪输入
            circleRadiusInput.value = 150;
            circleRadiusPercentage.textContent = '150px';

            // 清除所有预览
            clearAllPreviews();

            // 重置Canvas
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 如果切换到圆形裁剪模块，初始化Canvas
            const activeModule = document.querySelector('.module.active').id;
            if (activeModule === 'circularCropModule') {
              initializeCropCanvas();
            }
          };
        }
      }
      reader.readAsDataURL(file);
    });

    // 调整大小功能
    resizeButton.addEventListener('click', () => {
      if (!originalImageData) {
        alert('请先上传一张图片。');
        return;
      }

      const newWidth = parseInt(resizeWidthInput.value);
      const newHeight = parseInt(resizeHeightInput.value);

      if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) {
        alert('请输入有效的宽度和高度。');
        return;
      }

      // 创建一个新的Canvas用于调整大小
      const resizeCanvas = document.createElement('canvas');
      resizeCanvas.width = newWidth;
      resizeCanvas.height = newHeight;
      const resizeCtx = resizeCanvas.getContext('2d');

      // 绘制调整大小后的图像
      resizeCtx.drawImage(preloadedImage, 0, 0, newWidth, newHeight);

      // 获取调整大小后的图片URL
      const resizedDataURL = resizeCanvas.toDataURL('image/png');
      resizedImage.src = resizedDataURL;
      resizePreview.style.display = 'flex';
    });

    // 复原调整大小
    restoreResizeButton.addEventListener('click', () => {
      if (!originalImageData) return;

      resizeWidthInput.value = originalImageWidth;
      resizeHeightInput.value = originalImageHeight;
      resizedImage.src = '';
      resizePreview.style.display = 'none';
    });

    // 下载调整大小后的图片
    downloadResized.addEventListener('click', () => {
      const link = document.createElement('a');
      link.href = resizedImage.src;
      link.download = 'resized-image.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // 旋转功能
    rotateButton.addEventListener('click', () => {
      if (!originalImageData) {
        alert('请先上传一张图片。');
        return;
      }

      const angle = parseFloat(rotateAngleInput.value);
      if (isNaN(angle)) {
        alert('请输入有效的旋转角度。');
        return;
      }

      // 将角度转换为弧度
      const radians = angle * Math.PI / 180;

      // 计算旋转后的Canvas大小
      const rotatedWidth = Math.abs(originalImage.width * Math.cos(radians)) + Math.abs(originalImage.height * Math.sin(radians));
      const rotatedHeight = Math.abs(originalImage.width * Math.sin(radians)) + Math.abs(originalImage.height * Math.cos(radians));

      // 创建一个新的Canvas用于旋转
      const rotateCanvas = document.createElement('canvas');
      rotateCanvas.width = rotatedWidth;
      rotateCanvas.height = rotatedHeight;
      const rotateCtx = rotateCanvas.getContext('2d');

      // 将Canvas中心移动到旋转中心
      rotateCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
      rotateCtx.rotate(radians);
      rotateCtx.drawImage(preloadedImage, -originalImage.width / 2, -originalImage.height / 2);

      // 获取旋转后的图片URL
      const rotatedDataURL = rotateCanvas.toDataURL('image/png');
      rotatedImage.src = rotatedDataURL;
      rotatePreview.style.display = 'flex';
    });

    // 复原旋转
    restoreRotateButton.addEventListener('click', () => {
      if (!originalImageData) return;

      rotateAngleInput.value = 0;
      rotatedImage.src = '';
      rotatePreview.style.display = 'none';
    });

    // 下载旋转后的图片
    downloadRotated.addEventListener('click', () => {
      const link = document.createElement('a');
      link.href = rotatedImage.src;
      link.download = 'rotated-image.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // 压缩质量功能
    compressionQualityInput.addEventListener('input', () => {
      const quality = compressionQualityInput.value;
      compressionQualityPercentage.textContent = `${quality}%`;
    });

    compressionButton.addEventListener('click', () => {
      if (!originalImageData) {
        alert('请先上传一张图片。');
        return;
      }

      const quality = parseInt(compressionQualityInput.value) / 100;
      if (isNaN(quality) || quality <= 0 || quality > 1) {
        alert('请选择有效的压缩质量。');
        return;
      }

      // 创建一个新的Canvas用于压缩
      const compressionCanvas = document.createElement('canvas');
      compressionCanvas.width = originalImage.width;
      compressionCanvas.height = originalImage.height;
      const compressionCtx = compressionCanvas.getContext('2d');

      // 绘制图像
      compressionCtx.drawImage(preloadedImage, 0, 0, compressionCanvas.width, compressionCanvas.height);

      // 获取压缩后的图片URL
      const compressedDataURL = compressionCanvas.toDataURL('image/jpeg', quality);
      compressedImage.src = compressedDataURL;
      compressionPreview.style.display = 'flex';
    });

    // 复原压缩质量
    restoreCompressionButton.addEventListener('click', () => {
      if (!originalImageData) return;

      compressionQualityInput.value = 80;
      compressionQualityPercentage.textContent = '80%';
      compressedImage.src = '';
      compressionPreview.style.display = 'none';
    });

    // 下载压缩后的图片
    downloadCompressed.addEventListener('click', () => {
      const link = document.createElement('a');
      link.href = compressedImage.src;
      link.download = 'compressed-image.jpg';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // 圆角矩形功能
    roundedButton.addEventListener('click', () => {
      if (!originalImageData) {
        alert('请先上传一张图片。');
        return;
      }

      const radius = parseInt(cornerRadiusInput.value);
      if (isNaN(radius) || radius < 0) {
        alert('请输入有效的圆角半径。');
        return;
      }

      // 创建一个新的Canvas用于圆角矩形
      const roundedCanvas = document.createElement('canvas');
      roundedCanvas.width = originalImage.width;
      roundedCanvas.height = originalImage.height;
      const roundedCtx = roundedCanvas.getContext('2d');

      // 绘制圆角矩形路径
      roundedCtx.beginPath();
      roundedCtx.moveTo(radius, 0);
      roundedCtx.lineTo(roundedCanvas.width - radius, 0);
      roundedCtx.quadraticCurveTo(roundedCanvas.width, 0, roundedCanvas.width, radius);
      roundedCtx.lineTo(roundedCanvas.width, roundedCanvas.height - radius);
      roundedCtx.quadraticCurveTo(roundedCanvas.width, roundedCanvas.height, roundedCanvas.width - radius, roundedCanvas.height);
      roundedCtx.lineTo(radius, roundedCanvas.height);
      roundedCtx.quadraticCurveTo(0, roundedCanvas.height, 0, roundedCanvas.height - radius);
      roundedCtx.lineTo(0, radius);
      roundedCtx.quadraticCurveTo(0, 0, radius, 0);
      roundedCtx.closePath();

      // 裁剪为圆角矩形
      roundedCtx.clip();

      // 绘制图像
      roundedCtx.drawImage(preloadedImage, 0, 0, roundedCanvas.width, roundedCanvas.height);

      // 获取圆角矩形后的图片URL
      const roundedDataURL = roundedCanvas.toDataURL('image/png');
      roundedImage.src = roundedDataURL;
      roundedPreview.style.display = 'flex';
    });

    // 复原圆角矩形
    restoreRoundedButton.addEventListener('click', () => {
      if (!originalImageData) return;

      cornerRadiusInput.value = calculateRadius(originalImage.width);
      roundedImage.src = '';
      roundedPreview.style.display = 'none';
    });

    // 下载圆角矩形后的图片
    downloadRounded.addEventListener('click', () => {
      const link = document.createElement('a');
      link.href = roundedImage.src;
      link.download = 'rounded-image.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // 圆形裁剪功能

    let cropCircle = {
      x: 0,
      y: 0,
      radius: 150,
      isDragging: false,
      offsetX: 0,
      offsetY: 0
    };

    // 初始化裁剪Canvas
    function initializeCropCanvas() {
      if (!preloadedImage) return;

      // 设置Canvas尺寸为图片尺寸，限制为最大宽度以应对容器
      const maxCanvasWidth = 700; // 根据容器调整
      let scale = 1;
      if (preloadedImage.width > maxCanvasWidth) {
        scale = maxCanvasWidth / preloadedImage.width;
      }
      cropCanvas.width = preloadedImage.width * scale;
      cropCanvas.height = preloadedImage.height * scale;

      // 清空Canvas
      cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
      // 绘制缩放后的图片
      cropCtx.drawImage(preloadedImage, 0, 0, cropCanvas.width, cropCanvas.height);

      // 设置裁剪圆的初始位置和半径
      cropCircle.radius = Math.min(cropCanvas.width, cropCanvas.height) / 4; // 初始半径为四分之一
      circleRadiusInput.value = cropCircle.radius;
      circleRadiusPercentage.textContent = `${cropCircle.radius}px`;
      cropCircle.x = cropCanvas.width / 2;
      cropCircle.y = cropCanvas.height / 2;

      drawCropCircle();
    }

    // 绘制裁剪圆
    function drawCropCircle() {
      if (!preloadedImage) return;

      // 使用requestAnimationFrame优化绘制
      requestAnimationFrame(() => {
        // 清空Canvas并重新绘制图像
        cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
        cropCtx.drawImage(preloadedImage, 0, 0, cropCanvas.width, cropCanvas.height);

        // 绘制半透明覆盖层
        cropCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        cropCtx.beginPath();
        cropCtx.rect(0, 0, cropCanvas.width, cropCanvas.height);
        cropCtx.arc(cropCircle.x, cropCircle.y, cropCircle.radius, 0, Math.PI * 2, true);
        cropCtx.fill('evenodd');

        // 绘制圆形边框
        cropCtx.strokeStyle = '#fff';
        cropCtx.lineWidth = 2;
        cropCtx.beginPath();
        cropCtx.arc(cropCircle.x, cropCircle.y, cropCircle.radius, 0, Math.PI * 2, true);
        cropCtx.stroke();
      });
    }

    // 获取指针位置（鼠标或触摸）
    function getPointerPosition(e) {
      const rect = cropCanvas.getBoundingClientRect();
      let clientX, clientY;

      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    // 监听拖动事件
    cropCanvas.addEventListener('mousedown', (e) => {
      const pos = getPointerPosition(e);
      const distance = Math.hypot(pos.x - cropCircle.x, pos.y - cropCircle.y);
      if (distance <= cropCircle.radius) {
        cropCircle.isDragging = true;
        cropCircle.offsetX = cropCircle.x - pos.x;
        cropCircle.offsetY = cropCircle.y - pos.y;
      }
    });

    cropCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const pos = getPointerPosition(e);
      const distance = Math.hypot(pos.x - cropCircle.x, pos.y - cropCircle.y);
      if (distance <= cropCircle.radius) {
        cropCircle.isDragging = true;
        cropCircle.offsetX = cropCircle.x - pos.x;
        cropCircle.offsetY = cropCircle.y - pos.y;
      }
    }, { passive: false });

    cropCanvas.addEventListener('mousemove', (e) => {
      if (cropCircle.isDragging) {
        const pos = getPointerPosition(e);
        // 更新裁剪圆的位置
        cropCircle.x = pos.x + cropCircle.offsetX;
        cropCircle.y = pos.y + cropCircle.offsetY;

        // 限制裁剪圆不超出图片边界
        cropCircle.x = Math.max(cropCircle.radius, Math.min(cropCanvas.width - cropCircle.radius, cropCircle.x));
        cropCircle.y = Math.max(cropCircle.radius, Math.min(cropCanvas.height - cropCircle.radius, cropCircle.y));

        drawCropCircle();
      }
    });

    cropCanvas.addEventListener('touchmove', (e) => {
      if (cropCircle.isDragging) {
        e.preventDefault();
        const pos = getPointerPosition(e);
        // 更新裁剪圆的位置
        cropCircle.x = pos.x + cropCircle.offsetX;
        cropCircle.y = pos.y + cropCircle.offsetY;

        // 限制裁剪圆不超出图片边界
        cropCircle.x = Math.max(cropCircle.radius, Math.min(cropCanvas.width - cropCircle.radius, cropCircle.x));
        cropCircle.y = Math.max(cropCircle.radius, Math.min(cropCanvas.height - cropCircle.radius, cropCircle.y));

        drawCropCircle();
      }
    }, { passive: false });

    // 监听拖动结束事件
    window.addEventListener('mouseup', () => {
      if (cropCircle.isDragging) {
        cropCircle.isDragging = false;
      }
    });

    window.addEventListener('touchend', () => {
      if (cropCircle.isDragging) {
        cropCircle.isDragging = false;
      }
    });

    // 圆形半径滑块事件
    circleRadiusInput.addEventListener('input', () => {
      let newRadius = parseInt(circleRadiusInput.value);
      if (isNaN(newRadius) || newRadius <= 0) {
        return;
      }

      // 根据图片尺寸动态设置最大半径
      const maxRadius = Math.min(cropCanvas.width, cropCanvas.height) / 2;
      if (newRadius > maxRadius) {
        newRadius = maxRadius;
        circleRadiusInput.value = newRadius;
      }
      cropCircle.radius = newRadius;
      circleRadiusPercentage.textContent = `${newRadius}px`;

      // 确保裁剪圆在图片内
      cropCircle.x = Math.max(cropCircle.radius, Math.min(cropCanvas.width - cropCircle.radius, cropCircle.x));
      cropCircle.y = Math.max(cropCircle.radius, Math.min(cropCanvas.height - cropCircle.radius, cropCircle.y));

      drawCropCircle();
    });

    // 执行裁剪
    circularCropButton.addEventListener('click', () => {
      if (!originalImageData) {
        alert('请先上传一张图片。');
        return;
      }

      // 创建一个新的Canvas用于裁剪
      const outputCanvas = document.createElement('canvas');
      outputCanvas.width = cropCircle.radius * 2;
      outputCanvas.height = cropCircle.radius * 2;
      const outputCtx = outputCanvas.getContext('2d');

      // 绘制圆形裁剪区域
      outputCtx.beginPath();
      outputCtx.arc(cropCircle.radius, cropCircle.radius, cropCircle.radius, 0, Math.PI * 2, true);
      outputCtx.closePath();
      outputCtx.clip();

      // 计算原始图片上的裁剪区域
      const scaleX = originalImageWidth / cropCanvas.width;
      const scaleY = originalImageHeight / cropCanvas.height;

      const sourceX = (cropCircle.x - cropCircle.radius) * scaleX;
      const sourceY = (cropCircle.y - cropCircle.radius) * scaleY;
      const sourceWidth = cropCircle.radius * 2 * scaleX;
      const sourceHeight = cropCircle.radius * 2 * scaleY;

      // 使用预加载的图像对象
      outputCtx.drawImage(preloadedImage, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, outputCanvas.width, outputCanvas.height);

      // 获取裁剪后的图片URL
      const circularCroppedDataURL = outputCanvas.toDataURL('image/png');
      circularCroppedImage.src = circularCroppedDataURL;
      circularCropPreview.style.display = 'flex';
    });

    // 复原圆形裁剪
    restoreCircularCropButton.addEventListener('click', () => {
      if (!originalImageData) return;

      initializeCropCanvas();
      circularCroppedImage.src = '';
      circularCropPreview.style.display = 'none';
    });

    // 下载圆形裁剪后的图片
    downloadCircularCropped.addEventListener('click', () => {
      const link = document.createElement('a');
      link.href = circularCroppedImage.src;
      link.download = 'circular-cropped-image.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // 辅助函数：清除所有预览
    function clearAllPreviews() {
      // 调整大小预览
      resizedImage.src = '';
      resizePreview.style.display = 'none';

      // 旋转预览
      rotatedImage.src = '';
      rotatePreview.style.display = 'none';

      // 压缩质量预览
      compressedImage.src = '';
      compressionPreview.style.display = 'none';

      // 圆角矩形预览
      roundedImage.src = '';
      roundedPreview.style.display = 'none';

      // 圆形裁剪预览
      circularCroppedImage.src = '';
      circularCropPreview.style.display = 'none';

      // 清空裁剪Canvas
      cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
    }
  </script>
</body>
</html>
